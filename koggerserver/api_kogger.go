/*
 * API for kogger
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package koggerserver

import (
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	"net/http"

	"github.com/ZolaraProject/library/logger"
	"github.com/k-ogger/kogger-api/models"
	"github.com/k-ogger/kogger-service/koggerservicerpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

func GetNamespaces(w http.ResponseWriter, r *http.Request) {
	ctx, grpcToken := createContextFromHeader(r)

	conn, err := grpc.Dial(fmt.Sprintf("%v:%v", KoggerServiceHost, KoggerServicePort), grpc.WithInsecure(), grpc.WithBlock())
	if err != nil {
		logger.Err(grpcToken, "GetNamespaces could not establish gRPC connection: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("GetNamespaces could not establish gRPC connection: %v", err))
		return
	}
	defer conn.Close()
	client := koggerservicerpc.NewKoggerServiceClient(conn)

	res, err := client.GetNamespaces(ctx, &koggerservicerpc.Void{})
	if err != nil {
		logger.Err(grpcToken, "GetNamespaces failed: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("GetNamespaces failed: %s", err))
		return
	}

	responseObj := []models.NamespaceInList{}

	for _, namespace := range res.Namespaces {
		responseObj = append(responseObj, models.NamespaceInList{
			Name: namespace.Name,
			Path: namespace.Path,
		})
	}

	response, _ := json.Marshal(responseObj)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(response)
}

func GetLogs(w http.ResponseWriter, r *http.Request) {
	ctx, grpcToken := createContextFromHeader(r)

	conn, err := grpc.Dial(fmt.Sprintf("%v:%v", KoggerServiceHost, KoggerServicePort), grpc.WithInsecure(), grpc.WithBlock())
	if err != nil {
		logger.Err(grpcToken, "LogIn could not establish gRPC connection: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("LogIn could not establish gRPC connection: %v", err))
		return
	}
	defer conn.Close()
	client := koggerservicerpc.NewKoggerServiceClient(conn)

	res, err := client.GetLogs(ctx, &koggerservicerpc.LogsRequest{})
	if err != nil {
		logger.Err(grpcToken, "GetLogs failed: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("GetLogs failed: %s", err))
		return
	}

	responseObj := make([]models.Logs, len(res.Pods))
	for i, pod := range res.Pods {
		logResponse := models.Logs{
			Pod:       pod.Name,
			Namespace: pod.Namespace,
			Status:    pod.Status,
			Node:      pod.NodeName,
			Logs:      pod.Logs,
		}

		responseObj[i] = logResponse
	}

	logResponse := models.LogResponse{
		Logs: responseObj,
	}

	response, _ := json.Marshal(logResponse)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(response)
}

var (
	grpcTokenAlphabet = []byte("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ23456789")
)

func generateGrpcToken() string {
	tk := make([]byte, 16)
	for i := range tk {
		tk[i] = grpcTokenAlphabet[rand.Intn(len(grpcTokenAlphabet))]
	}
	return string(tk)
}

func createContextFromHeader(r *http.Request) (context.Context, string) {
	grpcToken := generateGrpcToken()

	ctx := metadata.AppendToOutgoingContext(r.Context(), "grpc-token", grpcToken)

	return ctx, grpcToken
}
